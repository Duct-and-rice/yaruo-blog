<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="target-densitydpi=device-dpi, width=1000"><title> About - 個人的やる夫まとめ</title><meta name="description" content="自分で書いたスレを主にまとめます"> <!--<link rel="stylesheet" href="/yaruo-blog/assets/main.css">--><style> * { -webkit-backface-visibility: hidden; backface-visibility: hidden; } .aa { font-family: Stmr, 'MS PGothic'; font-size: 16px; font-style: normal; font-weight: normal; letter-spacing: 0px; line-height: 18px; text-shadow: none; color: black; -moz-text-size-adjust: none; -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; word-break: break-all; white-space: nowrap; display: block; margin: 20px 0 !important; overflow: auto; white-space: nowrap; } .post-head { display: box; display: -webkit-box; display: -moz-box; box-pack: justify; -webkit-box-pack: justify; -moz-box-pack: justify; } .post-share { text-align: right; list-style: none; padding: 0; } .post-share a { background: #424242; display: inline-block; line-height: 1rem; width: 1rem; height: 1rem; border-radius: 50%; text-align: center; vertical-align: middle; padding: 5px; text-decoration: none; color: #e8e8e8; transition: .3s; } .post-share a:hover, .post-share a:visited { color: #e8e8e8; text-decoration: none; } .post-share a:hover { -ms-transform: translateY(4px); -webkit-transform: translateY(4px); transform: translateY(4px); } .post-share a.twitter { background: #55ACEE; } .post-share a.facebook { background: #3B5998; } .post-share a.google { background: #DD4B39; } .post-share a.hatenabookmark { background: #008FDE; } .post-share .sr-only { position: absolute; clip: rect(1px 1px 1px 1px); clip: rect(1px, 1px, 1px, 1px); padding: 0; border: 0; height: 1px; width: 1px; overflow: hidden; } .lsf, .lsf-icon:before { font-family: 'LigatureSymbols'; -webkit-text-rendering: optimizeLegibility; -moz-text-rendering: optimizeLegibility; -ms-text-rendering: optimizeLegibility; -o-text-rendering: optimizeLegibility; text-rendering: optimizeLegibility; -webkit-font-smoothing: antialiased; -moz-font-smoothing: antialiased; -ms-font-smoothing: antialiased; -o-font-smoothing: antialiased; font-smoothing: antialiased; } .lsf-icon:before { content: attr(title); margin-right: 0.3em; font-size: 130%; } .menu { display: inline-block; } .menu .menu-second li:not(:last-child) { margin-bottom: 10px; } .menu .menu-second { position: absolute; top: 20px; width: 10vw; /*-webkit-transition: all .2s ease;*/ /*transition: all .2s ease;*/ list-style-type: none; background-color: #e8e8e8; color: #828282; margin: 0px; padding: 10px; visibility: hidden; opacity: 0; z-index: 1; line-height: 20px; } .menu:hover ul.menu-second { top: 50px; visibility: visible; opacity: 1; } /** * Reset some basic elements */ body, h1, h2, h3, h4, h5, h6, p, blockquote, pre, hr, dl, dd, ol, ul, figure { margin: 0; padding: 0; } /** * Basic styling */ body { font: 400 16px/1.5 Bitter, "Apple SD Gothic Neo", AppleGothic, NanumBarunGothic, "Malgun Gothic", Dotum, sans-serif; color: #111; background-color: #fdfdfd; -webkit-text-size-adjust: 100%; -webkit-font-feature-settings: "kern" 1; -moz-font-feature-settings: "kern" 1; -o-font-feature-settings: "kern" 1; font-feature-settings: "kern" 1; font-kerning: normal; } /** * Set `margin-bottom` to maintain vertical rhythm */ h1, h2, h3, h4, h5, h6, p, blockquote, pre, ul, ol, dl, figure, .highlight { margin-bottom: 15px; } /** * Images */ img { max-width: 100%; vertical-align: middle; } /** * Figures */ figure > img { display: block; } figcaption { font-size: 14px; } /** * Lists */ ul, ol { margin-left: 30px; } li > ul, li > ol { margin-bottom: 0; } /** * Headings */ h1, h2, h3, h4, h5, h6 { font-weight: 400; } h1 code, h2 code, h3 code, h4 code, h5 code, h6 code { font-size: inherit; } /** * Links */ a { color: #2568ba; text-decoration: none; } a:visited { color: #1d508f; } a:hover { color: #111; text-decoration: underline; } /** * Blockquotes */ blockquote { color: #828282; border-left: 4px solid #e8e8e8; padding-left: 15px; font-size: 18px; letter-spacing: -1px; font-style: italic; } blockquote > :last-child { margin-bottom: 0; } /** * Rules */ hr { height: 4px; margin: 15px 0; border: 0; background-color: #e8e8e8; } /** * Code formatting */ pre, code { font-family: Monaco, Menlo, Consolas, "Courier New", DotumChe, monospace; font-size: 13px; border: 1px solid #e8e8e8; border-radius: 0; background-color: whitesmoke; } code { padding: 1px 5px; } pre { padding: 8px 12px; overflow-x: auto; } pre > code { border: 0; padding-right: 0; padding-left: 0; } /** * Wrapper */ .wrapper { max-width: -webkit-calc(1000px - (30px * 2)); max-width: calc(1000px - (30px * 2)); margin-right: auto; margin-left: auto; padding-right: 30px; padding-left: 30px; } @media screen and (max-width: 800px) { .wrapper { max-width: -webkit-calc(1000px - (30px)); max-width: calc(1000px - (30px)); padding-right: 15px; padding-left: 15px; } } /** * Clearfix */ .wrapper:after, .pagination:after { content: ""; display: table; clear: both; } /** * Site header */ .site-header { min-height: 56px; position: relative; } .site-title { font-size: 26px; font-weight: 300; line-height: 56px; letter-spacing: -1px; margin-bottom: 0; float: left; } .site-title, .site-title:visited { color: #424242; } .site-nav { float: right; line-height: 56px; } .site-nav .page-link { color: #111; line-height: 1.5; } .site-nav .page-link:not(:last-child) { margin-right: 20px; } @media screen and (max-width: 600px) { .site-nav .page-link { padding: 20px 0; margin-left: 20px; } .site-nav .page-link:not(:last-child) { margin-right: 0; } } /** * Site footer */ .site-footer { padding: 30px 0; font-size: 15px; color: #828282; text-align: center; } /** * Page content */ .page-content { padding: 30px 0; } .page-heading { font-size: 20px; } .post-list { margin-left: 0; list-style: none; } .post-list .post-link:hover { text-decoration: none; } .post-list > li { margin-bottom: 60px; } .post-list > li:not(:first-child) { border-top: 4px solid #e8e8e8; padding-top: 60px; } .post-archives { margin-left: 0; list-style: none; } .post-archives .post-link { font-size: 24px; } .post-archives > li { margin-bottom: 30px; } .post-meta { font-size: 14px; color: #828282; } .post-link, .post-link:visited { color: #111; } .post-link:hover { color: #2568ba; } .post-continue a { padding: 8px 15px; text-decoration: none; } .post-continue a, .post-continue a:visited { color: #828282; background-color: #e8e8e8; } .post-continue a:hover { color: white; background-color: #2568ba; } /** * Posts */ .post-header { margin-bottom: 30px; } .post-title { font-size: 42px; letter-spacing: -1px; line-height: 1; } @media screen and (max-width: 800px) { .post-title { font-size: 36px; } } .post-content { margin-bottom: 30px; } .post-content h2 { font-size: 32px; } @media screen and (max-width: 800px) { .post-content h2 { font-size: 28px; } } .post-content h3 { font-size: 26px; } @media screen and (max-width: 800px) { .post-content h3 { font-size: 22px; } } .post-content h4 { font-size: 20px; } @media screen and (max-width: 800px) { .post-content h4 { font-size: 18px; } } /** * Pagination */ .pagination { padding: 15px 0; border-top: 1px solid #e8e8e8; border-bottom: 1px solid #e8e8e8; text-align: center; } .pagination a, .pagination a:visited { color: #828282; } .pagination a:hover { color: #2568ba; } .pagination .previous { float: left; } .pagination .next { float: right; } /** * Syntax highlighting styles */ .highlight { background-color: whitesmoke; } .highlighter-rouge .highlight { background-color: whitesmoke; } .highlight .c { color: #998; font-style: italic; } .highlight .err { color: #a61717; background-color: #e3d2d2; } .highlight .k { font-weight: bold; } .highlight .o { font-weight: bold; } .highlight .cm { color: #998; font-style: italic; } .highlight .cp { color: #999; font-weight: bold; } .highlight .c1 { color: #998; font-style: italic; } .highlight .cs { color: #999; font-weight: bold; font-style: italic; } .highlight .gd { color: #000; background-color: #fdd; } .highlight .gd .x { color: #000; background-color: #faa; } .highlight .ge { font-style: italic; } .highlight .gr { color: #a00; } .highlight .gh { color: #999; } .highlight .gi { color: #000; background-color: #dfd; } .highlight .gi .x { color: #000; background-color: #afa; } .highlight .go { color: #888; } .highlight .gp { color: #555; } .highlight .gs { font-weight: bold; } .highlight .gu { color: #aaa; } .highlight .gt { color: #a00; } .highlight .kc { font-weight: bold; } .highlight .kd { font-weight: bold; } .highlight .kp { font-weight: bold; } .highlight .kr { font-weight: bold; } .highlight .kt { color: #458; font-weight: bold; } .highlight .m { color: #099; } .highlight .s { color: #d14; } .highlight .na { color: #008080; } .highlight .nb { color: #0086B3; } .highlight .nc { color: #458; font-weight: bold; } .highlight .no { color: #008080; } .highlight .ni { color: #800080; } .highlight .ne { color: #900; font-weight: bold; } .highlight .nf { color: #900; font-weight: bold; } .highlight .nn { color: #555; } .highlight .nt { color: #000080; } .highlight .nv { color: #008080; } .highlight .ow { font-weight: bold; } .highlight .w { color: #bbb; } .highlight .mf { color: #099; } .highlight .mh { color: #099; } .highlight .mi { color: #099; } .highlight .mo { color: #099; } .highlight .sb { color: #d14; } .highlight .sc { color: #d14; } .highlight .sd { color: #d14; } .highlight .s2 { color: #d14; } .highlight .se { color: #d14; } .highlight .sh { color: #d14; } .highlight .si { color: #d14; } .highlight .sx { color: #d14; } .highlight .sr { color: #009926; } .highlight .s1 { color: #d14; } .highlight .ss { color: #990073; } .highlight .bp { color: #999; } .highlight .vc { color: #008080; } .highlight .vg { color: #008080; } .highlight .vi { color: #008080; } .highlight .il { color: #099; }</style><style> /* https://cdn.rawgit.com/Duct-and-rice/yaruo-blog/1317c979/fonts/Saitamaar.ttf https://cdn.rawgit.com/Duct-and-rice/yaruo-blog/1317c979/fonts/Saitamaar.woff2 */ @font-face { font-family: 'Stmr'; src: url("https://cdn.rawgit.com/Duct-and-rice/yaruo-blog/1317c979/fonts/Saitamaar.woff2") format("woff2"), url("https://cdn.rawgit.com/Duct-and-rice/yaruo-blog/1317c979/fonts/Saitamaar.woff") format("woff"), url("https://cdn.rawgit.com/Duct-and-rice/yaruo-blog/1317c979/fonts/Saitamaar.ttf") format("truetype"), url("https://cdn.rawgit.com/Duct-and-rice/yaruo-blog/1317c979/fonts/Saitamaar.eot"), url("https://cdn.rawgit.com/Duct-and-rice/yaruo-blog/1317c979/fonts/Saitamaar.eot?#iefix") format("embedded-opentype"); font-weight: normal; font-display: auto; } /* latin-ext */ @font-face { font-family: 'Bitter'; font-style: italic; font-weight: 400; src: local("Bitter Italic"), local("Bitter-Italic"), url(https://fonts.gstatic.com/s/bitter/v11/PX9NwOMMeyM1S_WWulmbfhTbgVql8nDJpwnrE27mub0.woff2) format("woff2"); unicode-range: U+0100-024F, U+1E00-1EFF, U+20A0-20AB, U+20AD-20CF, U+2C60-2C7F, U+A720-A7FF; font-display: fallback; } /* latin */ @font-face { font-family: 'Bitter'; font-style: italic; font-weight: 400; src: local("Bitter Italic"), local("Bitter-Italic"), url(https://fonts.gstatic.com/s/bitter/v11/-t3SK6sofTjAH0MNf_tLaPesZW2xOQ-xsNqO47m55DA.woff2) format("woff2"); unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215; font-display: fallback; } /* latin-ext */ @font-face { font-family: 'Bitter'; font-style: normal; font-weight: 400; src: local("Bitter Regular"), local("Bitter-Regular"), url(https://fonts.gstatic.com/s/bitter/v11/Qt2dUzVlMd1bCOcZXl06LPesZW2xOQ-xsNqO47m55DA.woff2) format("woff2"); unicode-range: U+0100-024F, U+1E00-1EFF, U+20A0-20AB, U+20AD-20CF, U+2C60-2C7F, U+A720-A7FF; font-display: fallback; } /* latin */ @font-face { font-family: 'Bitter'; font-style: normal; font-weight: 400; src: local("Bitter Regular"), local("Bitter-Regular"), url(https://fonts.gstatic.com/s/bitter/v11/zfs6I-5mjWQ3nxqccMoL2A.woff2) format("woff2"); unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215; font-display: fallback; } /* latin-ext */ @font-face { font-family: 'Bitter'; font-style: normal; font-weight: 700; src: local("Bitter Bold"), local("Bitter-Bold"), url(https://fonts.gstatic.com/s/bitter/v11/JGVZEP92dXgoQBG1CnQcfBJtnKITppOI_IvcXXDNrsc.woff2) format("woff2"); unicode-range: U+0100-024F, U+1E00-1EFF, U+20A0-20AB, U+20AD-20CF, U+2C60-2C7F, U+A720-A7FF; font-display: fallback; } /* latin */ @font-face { font-family: 'Bitter'; font-style: normal; font-weight: 700; src: local("Bitter Bold"), local("Bitter-Bold"), url(https://fonts.gstatic.com/s/bitter/v11/evC1haE-MsorTl_A7_uSGVtXRa8TVwTICgirnJhmVJw.woff2) format("woff2"); unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215; font-display: fallback; } @font-face { font-family: 'LigatureSymbols'; src: url("https://cdn.rawgit.com/Duct-and-rice/yaruo-blog/1317c979/fonts/LigatureSymbols.eot"); src: url("https://cdn.rawgit.com/Duct-and-rice/yaruo-blog/1317c979/fonts/LigatureSymbols.eot?#iefix") format("embedded-opentype"), url("https://cdn.rawgit.com/Duct-and-rice/yaruo-blog/1317c979/fonts/LigatureSymbols.woff") format("woff"), url("https://cdn.rawgit.com/Duct-and-rice/yaruo-blog/1317c979/fonts/LigatureSymbols.ttf") format("truetype"), url("https://cdn.rawgit.com/Duct-and-rice/yaruo-blog/1317c979/fonts/LigatureSymbols.svg#LigatureSymbols") format("svg"); src: url("https://cdn.rawgit.com/Duct-and-rice/yaruo-blog/1317c979/fonts/LigatureSymbols.ttf") format("truetype"); font-weight: normal; font-style: normal; }</style><link rel="canonical" href="https://duct-and-rice.github.io/yaruo-blog/about/"><link rel="icon" sizes="any" href="https://rawcdn.githack.com/Duct-and-rice/yaruo-blog/1317c979/favicon.svg" type="image/svg+xml"><link rel="icon" sizes="96x96" href="https://rawcdn.githack.com/Duct-and-rice/yaruo-blog/1317c979/favicon.png" type="image/png"><link rel="alternate" type="application/rss+xml" title="個人的やる夫まとめ" href="https://duct-and-rice.github.io/yaruo-blog/feed.xml"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="wakeari_rosen"><meta name="twitter:title" content="About"><meta name="twitter:description" content="自分で書いたスレを主にまとめます"><meta name="twitter:creator" content="wakeari_rosen"> <script>/* InstantClick 3.1.0 | (C) 2014-2017 Alexandre Dieulot | http://instantclick.io/license */ var instantclick , InstantClick = instantclick = function(document, location, $userAgent) { // Internal variables var $currentLocationWithoutHash , $urlToPreload , $preloadTimer , $lastTouchTimestamp , $hasBeenInitialized , $touchEndedWithoutClickTimer , $lastUsedTimeoutId = 0 // Preloading-related variables , $history = {} , $xhr , $url = false , $title = false , $isContentTypeNotHTML , $areTrackedElementsDifferent , $body = false , $lastDisplayTimestamp = 0 , $isPreloading = false , $isWaitingForCompletion = false , $gotANetworkError = false , $trackedElementsData = [] // Variables defined by public functions , $preloadOnMousedown , $delayBeforePreload = 65 , $eventsCallbacks = { preload: [], receive: [], wait: [], change: [], restore: [], exit: [] } , $timers = {} , $currentPageXhrs = [] , $windowEventListeners = {} , $delegatedEvents = {} ////////// POLYFILL ////////// // Needed for `addEvent` if (!Element.prototype.matches) { Element.prototype.matches = Element.prototype.webkitMatchesSelector || Element.prototype.msMatchesSelector || function (selector) { var matches = document.querySelectorAll(selector) for (var i = 0; i < matches.length; i++) { if (matches[i] == this) { return true } } return false } } ////////// HELPERS ////////// function removeHash(url) { var index = url.indexOf('#') if (index == -1) { return url } return url.substr(0, index) } function getParentLinkElement(element) { while (element && element.nodeName != 'A') { element = element.parentNode } // `element` will be null if no link element is found return element } function isBlacklisted(element) { do { if (!element.hasAttribute) { // Parent of<html> break } if (element.hasAttribute('data-instant')) { return false } if (element.hasAttribute('data-no-instant')) { return true } } while (element = element.parentNode) return false } function isPreloadable(linkElement) { var domain = location.protocol + '//' + location.host if (linkElement.target // target="_blank" etc. || linkElement.hasAttribute('download') || linkElement.href.indexOf(domain + '/') != 0 // Another domain, or no href attribute || (linkElement.href.indexOf('#') > -1 && removeHash(linkElement.href) == $currentLocationWithoutHash) // Anchor || isBlacklisted(linkElement) ) { return false } return true } function triggerPageEvent(eventType) { var argumentsToApply = Array.prototype.slice.call(arguments, 1) , returnValue = false for (var i = 0; i < $eventsCallbacks[eventType].length; i++) { if (eventType == 'receive') { var altered = $eventsCallbacks[eventType][i].apply(window, argumentsToApply) if (altered) { // Update arguments for the next iteration of the loop. if ('body' in altered) { argumentsToApply[1] = altered.body } if ('title' in altered) { argumentsToApply[2] = altered.title } returnValue = altered } } else { $eventsCallbacks[eventType][i].apply(window, argumentsToApply) } } return returnValue } function changePage(title, body, urlToPush, scrollPosition) { abortCurrentPageXhrs() document.documentElement.replaceChild(body, document.body) // We cannot just use `document.body = doc.body`, it causes Safari (tested // 5.1, 6.0 and Mobile 7.0) to execute script tags directly. document.title = title if (urlToPush) { addOrRemoveWindowEventListeners('remove') if (urlToPush != location.href) { history.pushState(null, null, urlToPush) if ($userAgent.indexOf(' CriOS/') > -1) { // Chrome for iOS: // // 1. Removes title in tab on pushState, so it needs to be set after. // // 2. Will not set the title if it's identical after trimming, so we // add a non-breaking space. if (document.title == title) { document.title = title + String.fromCharCode(160) } else { document.title = title } } } var hashIndex = urlToPush.indexOf('#') , offsetElement = hashIndex > -1 && document.getElementById(urlToPush.substr(hashIndex + 1)) , offset = 0 if (offsetElement) { while (offsetElement.offsetParent) { offset += offsetElement.offsetTop offsetElement = offsetElement.offsetParent } } if ('requestAnimationFrame' in window) { // Safari on macOS doesn't immediately visually change the page on // `document.documentElement.replaceChild`, so if `scrollTo` is called // without `requestAnimationFrame` it often scrolls before the page // is displayed. requestAnimationFrame(function() { scrollTo(0, offset) }) } else { scrollTo(0, offset) // Safari on macOS scrolls before the page is visually changed, but // adding `requestAnimationFrame` doesn't fix it in this case. } clearCurrentPageTimeouts() $currentLocationWithoutHash = removeHash(urlToPush) if ($currentLocationWithoutHash in $windowEventListeners) { $windowEventListeners[$currentLocationWithoutHash] = [] } $timers[$currentLocationWithoutHash] = {} applyScriptElements(function(element) { return !element.hasAttribute('data-instant-track') }) triggerPageEvent('change', false) } else { // On popstate, browsers scroll by themselves, but at least Firefox // scrolls BEFORE popstate is fired and thus before we can replace the // page. If the page before popstate is too short the user won't be // scrolled at the right position as a result. We need to scroll again. scrollTo(0, scrollPosition) // iOS's gesture to go back by swiping from the left edge of the screen // will start a preloading if the user touches a link, it needs to be // cancelled otherwise the page behind the touched link will be // displayed. $xhr.abort() setPreloadingAsHalted() applyScriptElements(function(element) { return element.hasAttribute('data-instant-restore') }) restoreTimers() triggerPageEvent('restore') } } function setPreloadingAsHalted() { $isPreloading = false $isWaitingForCompletion = false } function removeNoscriptTags(html) { // Must be done on text, not on a node's innerHTML, otherwise strange // things happen with implicitly closed elements (see the Noscript test). return html.replace(/<noscript[\s\S]+?<\/noscript>/gi, '') } function abortCurrentPageXhrs() { for (var i = 0; i < $currentPageXhrs.length; i++) { if (typeof $currentPageXhrs[i] == 'object' && 'abort' in $currentPageXhrs[i]) { $currentPageXhrs[i].instantclickAbort = true $currentPageXhrs[i].abort() } } $currentPageXhrs = [] } function clearCurrentPageTimeouts() { for (var i in $timers[$currentLocationWithoutHash]) { var timeout = $timers[$currentLocationWithoutHash][i] window.clearTimeout(timeout.realId) timeout.delayLeft = timeout.delay - +new Date + timeout.timestamp } } function restoreTimers() { for (var i in $timers[$currentLocationWithoutHash]) { if (!('delayLeft' in $timers[$currentLocationWithoutHash][i])) { continue } var args = [ $timers[$currentLocationWithoutHash][i].callback, $timers[$currentLocationWithoutHash][i].delayLeft ] for (var j = 0; j < $timers[$currentLocationWithoutHash][i].params.length; j++) { args.push($timers[$currentLocationWithoutHash][i].params[j]) } addTimer(args, $timers[$currentLocationWithoutHash][i].isRepeating, $timers[$currentLocationWithoutHash][i].delay) delete $timers[$currentLocationWithoutHash][i] } } function handleTouchendWithoutClick() { $xhr.abort() setPreloadingAsHalted() } function addOrRemoveWindowEventListeners(addOrRemove) { if ($currentLocationWithoutHash in $windowEventListeners) { for (var i = 0; i < $windowEventListeners[$currentLocationWithoutHash].length; i++) { window[addOrRemove + 'EventListener'].apply(window, $windowEventListeners[$currentLocationWithoutHash][i]) } } } function applyScriptElements(condition) { var scriptElementsInDOM = document.body.getElementsByTagName('script') , scriptElementsToCopy = [] , originalElement , copyElement , parentNode , nextSibling , i // `scriptElementsInDOM` will change during the copy of scripts if // a script add or delete script elements, so we need to put script // elements in an array to loop through them correctly. for (i = 0; i < scriptElementsInDOM.length; i++) { scriptElementsToCopy.push(scriptElementsInDOM[i]) } for (i = 0; i < scriptElementsToCopy.length; i++) { originalElement = scriptElementsToCopy[i] if (!originalElement) { // Might have disappeared, see previous comment continue } if (!condition(originalElement)) { continue } copyElement = document.createElement('script') for (var j = 0; j < originalElement.attributes.length; j++) { copyElement.setAttribute(originalElement.attributes[j].name, originalElement.attributes[j].value) } copyElement.textContent = originalElement.textContent parentNode = originalElement.parentNode nextSibling = originalElement.nextSibling parentNode.removeChild(originalElement) parentNode.insertBefore(copyElement, nextSibling) } } function addTrackedElements() { var trackedElements = document.querySelectorAll('[data-instant-track]') , element , elementData for (var i = 0; i < trackedElements.length; i++) { element = trackedElements[i] elementData = element.getAttribute('href') || element.getAttribute('src') || element.textContent // We can't use just `element.href` and `element.src` because we can't // retrieve `href`s and `src`s from the Ajax response. $trackedElementsData.push(elementData) } } function addTimer(args, isRepeating, realDelay) { var callback = args[0] , delay = args[1] , params = [].slice.call(args, 2) , timestamp = +new Date $lastUsedTimeoutId++ var id = $lastUsedTimeoutId var callbackModified if (isRepeating) { callbackModified = function(args2) { callback(args2) delete $timers[$currentLocationWithoutHash][id] args[0] = callback args[1] = delay addTimer(args, true) } } else { callbackModified = function(args2) { callback(args2) delete $timers[$currentLocationWithoutHash][id] } } args[0] = callbackModified if (realDelay != undefined) { timestamp += delay - realDelay delay = realDelay } var realId = window.setTimeout.apply(window, args) $timers[$currentLocationWithoutHash][id] = { realId: realId, timestamp: timestamp, callback: callback, delay: delay, params: params, isRepeating: isRepeating } return -id } ////////// EVENT LISTENERS ////////// function mousedownListener(event) { var linkElement = getParentLinkElement(event.target) if (!linkElement || !isPreloadable(linkElement)) { return } preload(linkElement.href) } function mouseoverListener(event) { if ($lastTouchTimestamp > (+new Date - 500)) { // On a touch device, if the content of the page change on mouseover // click is never fired and the user will need to tap a second time. // https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html#//apple_ref/doc/uid/TP40006511-SW4 // // Content change could happen in the `preload` event, so we stop there. return } if (+new Date - $lastDisplayTimestamp < 100) { // After a page is displayed, if the user's cursor happens to be above // a link a mouseover event will be in most browsers triggered // automatically, and in other browsers it will be triggered when the // user moves his mouse by 1px. // // Here are the behaviors I noticed, all on Windows: // - Safari 5.1: auto-triggers after 0 ms // - IE 11: auto-triggers after 30-80 ms (depends on page's size?) // - Firefox: auto-triggers after 10 ms // - Opera 18: auto-triggers after 10 ms // // - Chrome: triggers when cursor moved // - Opera 12.16: triggers when cursor moved // // To remedy to this, we do nothing if the last display occurred less // than 100 ms ago. return } var linkElement = getParentLinkElement(event.target) if (!linkElement) { return } if (linkElement == getParentLinkElement(event.relatedTarget)) { // Happens when mouseout-ing and mouseover-ing child elements of the same link element return } if (!isPreloadable(linkElement)) { return } linkElement.addEventListener('mouseout', mouseoutListener) if (!$isWaitingForCompletion) { $urlToPreload = linkElement.href $preloadTimer = setTimeout(preload, $delayBeforePreload) } } function touchstartListener(event) { $lastTouchTimestamp = +new Date var linkElement = getParentLinkElement(event.target) if (!linkElement || !isPreloadable(linkElement)) { return } if ($touchEndedWithoutClickTimer) { clearTimeout($touchEndedWithoutClickTimer) $touchEndedWithoutClickTimer = false } linkElement.addEventListener('touchend', touchendAndTouchcancelListener) linkElement.addEventListener('touchcancel', touchendAndTouchcancelListener) preload(linkElement.href) } function clickListenerPrelude() { // Makes clickListener be fired after everyone else, so that we can respect // event.preventDefault. document.addEventListener('click', clickListener) } function clickListener(event) { document.removeEventListener('click', clickListener) if ($touchEndedWithoutClickTimer) { clearTimeout($touchEndedWithoutClickTimer) $touchEndedWithoutClickTimer = false } if (event.defaultPrevented) { return } var linkElement = getParentLinkElement(event.target) if (!linkElement || !isPreloadable(linkElement)) { return } // Check if it's opening in a new tab if (event.button != 0 // Chrome < 55 fires a click event when the middle mouse button is pressed || event.metaKey || event.ctrlKey) { return } event.preventDefault() display(linkElement.href) } function mouseoutListener(event) { if (getParentLinkElement(event.target) == getParentLinkElement(event.relatedTarget)) { // Happens when mouseout-ing and mouseover-ing child elements of the same link element, // we don't want to stop preloading then. return } if ($preloadTimer) { clearTimeout($preloadTimer) $preloadTimer = false return } if (!$isPreloading || $isWaitingForCompletion) { return } $xhr.abort() setPreloadingAsHalted() } function touchendAndTouchcancelListener(event) { if (!$isPreloading || $isWaitingForCompletion) { return } $touchEndedWithoutClickTimer = setTimeout(handleTouchendWithoutClick, 500) } function readystatechangeListener() { if ($xhr.readyState == 2) { // headers received var contentType = $xhr.getResponseHeader('Content-Type') if (!contentType || !/^text\/html/i.test(contentType)) { $isContentTypeNotHTML = true } } if ($xhr.readyState < 4) { return } if ($xhr.status == 0) { // Request error/timeout/abort $gotANetworkError = true if ($isWaitingForCompletion) { triggerPageEvent('exit', $url, 'network error') location.href = $url } return } if ($isContentTypeNotHTML) { if ($isWaitingForCompletion) { triggerPageEvent('exit', $url, 'non-html content-type') location.href = $url } return } var doc = document.implementation.createHTMLDocument('') doc.documentElement.innerHTML = removeNoscriptTags($xhr.responseText) $title = doc.title $body = doc.body var alteredOnReceive = triggerPageEvent('receive', $url, $body, $title) if (alteredOnReceive) { if ('body' in alteredOnReceive) { $body = alteredOnReceive.body } if ('title' in alteredOnReceive) { $title = alteredOnReceive.title } } var urlWithoutHash = removeHash($url) $history[urlWithoutHash] = { body: $body, title: $title, scrollPosition: urlWithoutHash in $history ? $history[urlWithoutHash].scrollPosition : 0 } var trackedElements = doc.querySelectorAll('[data-instant-track]') , element , elementData if (trackedElements.length != $trackedElementsData.length) { $areTrackedElementsDifferent = true } else { for (var i = 0; i < trackedElements.length; i++) { element = trackedElements[i] elementData = element.getAttribute('href') || element.getAttribute('src') || element.textContent if ($trackedElementsData.indexOf(elementData) == -1) { $areTrackedElementsDifferent = true } } } if ($isWaitingForCompletion) { $isWaitingForCompletion = false display($url) } } function popstateListener() { var loc = removeHash(location.href) if (loc == $currentLocationWithoutHash) { return } if ($isWaitingForCompletion) { setPreloadingAsHalted() $xhr.abort() } if (!(loc in $history)) { triggerPageEvent('exit', location.href, 'not in history') if (loc == location.href) { // no location.hash location.href = location.href // Reloads the page while using cache for scripts, styles and images, // unlike `location.reload()` } else { // When there's a hash, `location.href = location.href` won't reload // the page (but will trigger a popstate event, thus causing an infinite // loop), so we need to call `location.reload()` location.reload() } return } $history[$currentLocationWithoutHash].scrollPosition = pageYOffset clearCurrentPageTimeouts() addOrRemoveWindowEventListeners('remove') $currentLocationWithoutHash = loc changePage($history[loc].title, $history[loc].body, false, $history[loc].scrollPosition) addOrRemoveWindowEventListeners('add') } ////////// MAIN FUNCTIONS ////////// function preload(url) { if ($preloadTimer) { clearTimeout($preloadTimer) $preloadTimer = false } if (!url) { url = $urlToPreload } if ($isPreloading && (url == $url || $isWaitingForCompletion)) { return } $isPreloading = true $isWaitingForCompletion = false $url = url $body = false $isContentTypeNotHTML = false $gotANetworkError = false $areTrackedElementsDifferent = false triggerPageEvent('preload') $xhr.open('GET', url) $xhr.timeout = 90000 // Must be set after `open()` with IE $xhr.send() } function display(url) { $lastDisplayTimestamp = +new Date if ($preloadTimer || !$isPreloading) { // $preloadTimer: // Happens when there's a delay before preloading and that delay // hasn't expired (preloading didn't kick in). // // !$isPreloading: // A link has been clicked, and preloading hasn't been initiated. // It happens with touch devices when a user taps *near* the link, // causing `touchstart` not to be fired. Safari/Chrome will trigger // `mouseover`, `mousedown`, `click` (and others), but when that happens // we do nothing in `mouseover` as it may cause `click` not to fire (see // comment in `mouseoverListener`). // // It also happens when a user uses his keyboard to navigate (with Tab // and Return), and possibly in other non-mainstream ways to navigate // a website. if ($preloadTimer && $url && $url != url) { // Happens when the user clicks on a link before preloading // kicks in while another link is already preloading. triggerPageEvent('exit', url, 'click occured while preloading planned') location.href = url return } preload(url) triggerPageEvent('wait') $isWaitingForCompletion = true // Must be set *after* calling `preload` return } if ($isWaitingForCompletion) { // The user clicked on a link while a page to display was preloading. // Either on the same link or on another link. If it's the same link // something might have gone wrong (or he could have double clicked, we // don't handle that case), so we send him to the page without pjax. // If it's another link, it hasn't been preloaded, so we redirect the // user to it. triggerPageEvent('exit', url, 'clicked on a link while waiting for another page to display') location.href = url return } if ($isContentTypeNotHTML) { triggerPageEvent('exit', $url, 'non-html content-type') location.href = $url return } if ($gotANetworkError) { triggerPageEvent('exit', $url, 'network error') location.href = $url return } if ($areTrackedElementsDifferent) { triggerPageEvent('exit', $url, 'different assets') location.href = $url return } if (!$body) { triggerPageEvent('wait') $isWaitingForCompletion = true return } $history[$currentLocationWithoutHash].scrollPosition = pageYOffset setPreloadingAsHalted() changePage($title, $body, $url) } ////////// PUBLIC VARIABLE AND FUNCTIONS ////////// var supported = false if ('pushState' in history && location.protocol != "file:") { supported = true var indexOfAndroid = $userAgent.indexOf('Android ') if (indexOfAndroid > -1) { // The stock browser in Android 4.0.3 through 4.3.1 supports pushState, // though it doesn't update the address bar. // // More problematic is that it has a bug on `popstate` when coming back // from a page not displayed through InstantClick: `location.href` is // undefined and `location.reload()` doesn't work. // // Android < 4.4 is therefore blacklisted, unless it's a browser known // not to have that latter bug. var androidVersion = parseFloat($userAgent.substr(indexOfAndroid + 'Android '.length)) if (androidVersion < 4.4) { supported = false if (androidVersion >= 4) { var whitelistedBrowsersUserAgentsOnAndroid4 = [ / Chrome\//, // Chrome, Opera, Puffin, QQ, Yandex / UCBrowser\//, / Firefox\//, / Windows Phone /, // WP 8.1+ pretends to be Android ] for (var i = 0; i < whitelistedBrowsersUserAgentsOnAndroid4.length; i++) { if (whitelistedBrowsersUserAgentsOnAndroid4[i].test($userAgent)) { supported = true break } } } } } } function init(preloadingMode) { if (!supported) { triggerPageEvent('change', true) return } if ($hasBeenInitialized) { return } $hasBeenInitialized = true if (preloadingMode == 'mousedown') { $preloadOnMousedown = true } else if (typeof preloadingMode == 'number') { $delayBeforePreload = preloadingMode } $currentLocationWithoutHash = removeHash(location.href) $timers[$currentLocationWithoutHash] = {} $history[$currentLocationWithoutHash] = { body: document.body, title: document.title, scrollPosition: pageYOffset } if (document.readyState == 'loading') { document.addEventListener('DOMContentLoaded', addTrackedElements) } else { addTrackedElements() } $xhr = new XMLHttpRequest() $xhr.addEventListener('readystatechange', readystatechangeListener) document.addEventListener('touchstart', touchstartListener, true) if ($preloadOnMousedown) { document.addEventListener('mousedown', mousedownListener, true) } else { document.addEventListener('mouseover', mouseoverListener, true) } document.addEventListener('click', clickListenerPrelude, true) addEventListener('popstate', popstateListener) } function on(eventType, callback) { $eventsCallbacks[eventType].push(callback) if (eventType == 'change') { callback(!$lastDisplayTimestamp) } } function setTimeout() { return addTimer(arguments, false) } function setInterval() { return addTimer(arguments, true) } function clearTimeout(id) { id = -id for (var loc in $timers) { if (id in $timers[loc]) { window.clearTimeout($timers[loc][id].realId) delete $timers[loc][id] } } } function xhr(xhr) { $currentPageXhrs.push(xhr) } function addPageEvent() { if (!($currentLocationWithoutHash in $windowEventListeners)) { $windowEventListeners[$currentLocationWithoutHash] = [] } $windowEventListeners[$currentLocationWithoutHash].push(arguments) addEventListener.apply(window, arguments) } function removePageEvent() { if (!($currentLocationWithoutHash in $windowEventListeners)) { return } firstLoop: for (var i = 0; i < $windowEventListeners[$currentLocationWithoutHash].length; i++) { if (arguments.length != $windowEventListeners[$currentLocationWithoutHash][i].length) { continue } for (var j = 0; j < $windowEventListeners[$currentLocationWithoutHash][i].length; j++) { if (arguments[j] != $windowEventListeners[$currentLocationWithoutHash][i][j]) { continue firstLoop } } $windowEventListeners[$currentLocationWithoutHash].splice(i, 1) } } function addEvent(selector, type, listener) { if (!(type in $delegatedEvents)) { $delegatedEvents[type] = {} document.addEventListener(type, function(event) { var element = event.target event.originalStopPropagation = event.stopPropagation event.stopPropagation = function() { this.isPropagationStopped = true this.originalStopPropagation() } while (element && element.nodeType == 1) { for (var selector in $delegatedEvents[type]) { if (element.matches(selector)) { for (var i = 0; i < $delegatedEvents[type][selector].length; i++) { $delegatedEvents[type][selector][i].call(element, event) } if (event.isPropagationStopped) { return } break } } element = element.parentNode } }, false) // Third parameter isn't optional in Firefox < 6 if (type == 'click' && /iP(?:hone|ad|od)/.test($userAgent)) { // Force Mobile Safari to trigger the click event on document by adding a pointer cursor to body var styleElement = document.createElement('style') styleElement.setAttribute('instantclick-mobile-safari-cursor', '') // So that this style element doesn't surprise developers in the browser DOM inspector. styleElement.textContent = 'body { cursor: pointer !important; }' document.head.appendChild(styleElement) } } if (!(selector in $delegatedEvents[type])) { $delegatedEvents[type][selector] = [] } // Run removeEvent beforehand so that it can't be added twice removeEvent(selector, type, listener) $delegatedEvents[type][selector].push(listener) } function removeEvent(selector, type, listener) { var index = $delegatedEvents[type][selector].indexOf(listener) if (index > -1) { $delegatedEvents[type][selector].splice(index, 1) } } //////////////////// return { supported: supported, init: init, on: on, setTimeout: setTimeout, setInterval: setInterval, clearTimeout: clearTimeout, xhr: xhr, addPageEvent: addPageEvent, removePageEvent: removePageEvent, addEvent: addEvent, removeEvent: removeEvent } }(document, location, navigator.userAgent); ;InstantClick.init();</script><body><header class="site-header"><div class="wrapper"> <a class="site-title" href="/yaruo-blog/">個人的やる夫まとめ</a><nav class="site-nav"> <a class="page-link" href="/yaruo-blog/about/" >About</a> <a class="page-link" href="/yaruo-blog/archives/" >Archives</a><div class="menu"> <a class="page-link menu-init" href="/yaruo-blog/ours/" >Ours</a><ul class="menu-second"><li> <a href="/yaruo-blog/categories/internet-casefile"> AAで学ぶネット事件簿 </a><li> <a href="/yaruo-blog/categories/short"> 短編 </a></ul></div><div class="menu"> <a class="page-link menu-init" href="/yaruo-blog/others/" >Others</a><ul class="menu-second"><li> <a href="/yaruo-blog/categories/short-others"> 短編 </a><li> <a href="/yaruo-blog/categories/short-foods"> デス飲食短編勝負 地雷爆破デスマッチ </a></ul></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><header class="post-header"><h1 class="post-title">About</h1></header><div class="post-content"><h1 id="このブログについて">このブログについて</h1><p>このブログは、主に管理人ダクト飯が制作したやる夫スレをまとめるブログです。掲載依頼などがあれば別の記事が載るかもしれません。<h1 id="このブログの構成について">このブログの構成について</h1><p>Jekyllで構築しGithub Pagesで公開しています。<h1 id="謝辞">謝辞</h1><p>このブログではJekyll、whiteglass、Saitamaarフォント、Googleフォント、Simple Share Buttonsを使用しています。<p>また、Saitamaarフォントに関しては配布がHTTPなので一回無断で再配布という形を取らせていただきます。お叱りを受けたらすぐやめます。<h1 id="寄付">寄付</h1><p>Bitcoin:1GN2CmNsXsZEXTy6mwn3nxcc5rDETGSg3p</div></article></div></main><footer class="site-footer"><div class="wrapper"><p><p><a href="https://travis-ci.org/Duct-and-rice/yaruo-blog" target=”_blank”> <img alt="Travis CI" src="https://img.shields.io/travis/Duct-and-rice/yaruo-blog.svg"> </a><p>&copy; Duct-and-rice - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://duct-and-rice.github.io/yaruo-blog/feed.xml">RSS</a><p>Bitcoin:1GN2CmNsXsZEXTy6mwn3nxcc5rDETGSg3p</div></footer>
